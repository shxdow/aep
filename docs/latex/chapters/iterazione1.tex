\section{Introduzione}

In questa fase vengono implementate le strutture e le funzioni utili al fine di avere un
\textit{Minimum Viable Product} funzionante.

La funzione principale implementata è la \texttt{FU3}, ovvero il \textit{login} ed il \textit{logout}
di persone con account (sia utenti sia operatori).
Altre funzioni realizzate sono
\begin{itemize}
  \item \texttt{FU1}, la creazione di un account;
  \item \texttt{FT7}, l'assegnamento manuale di un ticket;
  \item \texttt{FO1}, la creazione di un operatore;
  \item \texttt{FO2}, la modifica di un operatore;
  \item \texttt{FO3}, l'eliminazione di un operatore.
\end{itemize}

Oltre all'autenticazione, è stata realizzata anche la struttura dell'applicazione sia lato back-end, in
linguaggio \textit{Python} e con il framework \textit{Django}, sia lato front-end, usando i linguaggi
\textit{JavaScript}, \textit{HTML} e \textit{CSS} e con la libreria \textit{React}.

\section{Back-end e REST API}

Il back-end è un server REST realizzato grazie ai framework \textit{Django} e \textit{Django REST Framework},
che si occupano rispettivamente della gestione completa\footnote{Comprendente accesso a database, templating, autorizzazioni, etc.}
di un server in Python e della creazione e mantenimento di API Web.

\subsection{Autenticazione}
\label{sec:back-end-auth}

L'autenticazione è gestita trasparentemente grazie a \textit{Django}, che offre tutte le possibili funzioni
per la gestione di utenti e di sessioni.

Come esempio, di seguito è visibile la definizione di un \texttt{Account}, entità usata per l'accesso al portale.

\begin{lstlisting}[language=Python]
from django.db import models
from django.contrib.auth.models import User

class Account(models.Model):
    """
        Account models
    """

    user = models.OneToOneField(User, on_delete=models.CASCADE)
    name = models.CharField(max_length=72, null=True)
    email = models.CharField(max_length=72)
\end{lstlisting}

Come si può vedere, però, la classe \texttt{Account} non estende la classe predefinita \texttt{User},
questo perché il framework stesso consiglia la creazione di un riferimento ad un'istanza di utente
piuttosto che la classica ereditarietà\footnote{https://docs.djangoproject.com/en/3.1/topics/auth/customizing/}.

Qui si vede inoltre perché (anticipato dal diagramma delle classi) non abbiamo chiamato \texttt{User}
la classe relativa agli attori di tipo ``utente'', ovvero per evitare un conflitto di nomi con le classi
fornite dal framework.

Per limitare l'accesso invece a particolari endpoint viene fornito il decoratore \texttt{@login\_required},
che va posto sopra le funzioni e/o metodi che necessitano di una sessione attiva, come si può qui vedere nell'estratto
di codice.

\begin{lstlisting}[language=Python]
@login_required
@api_view(['POST'])
def add_operator(request):
    """
        Let admins add operator
    """
    try:
        user = User.objects.create_user(username=request.data["username"],
                                        password=request.data["password"])

        user.save()
        acc = Account(user=user, email=request.data["username"])
        acc.save()
        operator = Operator(account=acc, group=None)
        operator.save()
    except Exception as e:
        return Response(status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    return Response(status=status.HTTP_201_CREATED)
\end{lstlisting}

\subsection{App AI}

Una \textit{app} in \textit{Django} è un pacchetto Python che fornisce delle funzionalità e ha delle
proprie configurazioni. Nel nostro caso, \texttt{ai} è la app principale (e anche l'unica) che offre tutte
le funzionalità definite nella fase precedente.

Seppur in \textit{Django} è possibile utilizzare dei \textit{template HTML} per la realizzazione anche
dell'interfaccia grafica, essi non sono usati nel nostro progetto, in quanto il front-end è separato e
realizzato in modo indipendente dal back-end.

I file presenti di particolare interesse sono:
\begin{itemize}
  \item \texttt{models.py} che contiene tutti i modelli usati per derivare la struttura del database e le migrazioni;
  \item \texttt{tests.py} contente i vari test;
  \item \texttt{urls.py} per la definizione degli endpoint forniti;
  \item \texttt{views.py}, il quale elenca le varie rappresentazioni dei dati e le azioni possibili su di essi.
\end{itemize}

Le relazioni statiche presenti nella app AI sono visibili in figura \ref{fig:app-ai-er}.
Come si può vedere, sono presenti sia classi definite da noi sia classi del framework.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{app-ai-er.png}
  \caption{Relazioni tra classi di AI}
  \label{fig:app-ai-er}
\end{figure}

\subsection{Console di amministrazione}

La console di amministrazione, usata dagli attori \textit{Amministratori}, è generata
automaticamente dal framework \textit{Django} su un sottoinsieme delle entità da noi definite a livello di codice.

Grazie ad essa è possibile

\begin{itemize}
  \item assegnare manualmente un operatore ad un gruppo;
  \item assegnare manualmente un ticket ad un gruppo;
  \item creare, modificare ed eliminare operatori ed i loro account.
\end{itemize}

Nella figura \ref{fig:django-admin-console} è visibile il form per l'accesso a questa console, disponibile all'endpoint \texttt{/admin/}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{django-admin-login.jpg}
  \caption{Admin console di Django}
  \label{fig:django-admin-console}
\end{figure}

\subsection{API endpoints}

Il server mette a disposizione degli endpoint per fornire, creare e modificare i dati relativi al dominio.
Questi sono visibili nella tabella \ref{tab:server-rest-apis}.

\begin{table}
  \centering
  \begin{tabular}{|l|l|l|}
    \hline Metodo & Endpoint & Funzione \\
    \hline
    \hline \texttt{POST} & \texttt{v1/auth/} & Login \\
    \hline \texttt{POST} & \texttt{v1/signup/} & Registrazione \\
    \hline \texttt{POST} & \texttt{v1/operator/add/} & Creazione di operatori \\
    \hline \texttt{GET/PUT/DELETE} & \texttt{v1/operator/<int:pk>/} & Gestione di operatori \\
    \hline \texttt{POST} & \texttt{v1/client/add/} & Creazione di clienti (i.e. utenti) \\
    \hline \texttt{GET/PUT/DELETE} & \texttt{v1/client/<int:pk>/} & Gestione di clienti \\
    \hline \texttt{POST} & \texttt{v1/group/add/} & Creazione di gruppi \\
    \hline \texttt{GET/PUT/DELETE} & \texttt{v1/group/<int:pk>/} & Gestione di gruppi \\
    \hline
  \end{tabular}
  \caption{API fornite dal server}
  \label{tab:server-rest-apis}
\end{table}

Notare che questi endpoint sono solamente quelli realizzati in questa iterazione: nelle iterazioni future
se ne aggiungeranno altri in base alle necessità implementative di ogni funzionalità.

\section{Front-end}

Il front-end è una \textit{Single Page Application} realizzata in \textit{JavaScript} con l'ausilio
della libreria open source \textit{React}. Grazie ad essa è possibile costruire componenti grafici
riutilizzabili, i quali possono anche contenere logica interna complessa.

\subsection{Struttura SPA}

Il codice è suddiviso in varie cartelle\footnote{La struttura del progetto non è data da un
framework, ma da esperienza personale.}, ma la cartella \texttt{src} contiene tutto il codice.
A sua volta, \texttt{src} è divisa in:

\begin{itemize}
  \item \texttt{components}, contenente componenti di pura grafica, indipendenti da dati di dominio;
  \item \texttt{resources}, per alcune risorse statiche (come ad esempio immagini);
  \item \texttt{scenes}, che racchiude le varie pagine con cui l'utente interagisce;
  \item \texttt{theme}, per i CSS ed i font usati nel sito.
\end{itemize}

Non appartenenti a questa cartella sono \texttt{App.jsx}, che si occupa del rendering della SPA, e
\texttt{AppRouting.jsx}, che definisce le varie rotte visitabili.

\subsection{Pagine visitabili}

\section{Analisi statica}

\subsection{Front-end}

Per il front-end è stata utilizzata \textit{ESLint}, una libreria JavaScript che analizza staticamente il codice e
risolve problemi sia di stile, sia di code quality. 

In particolare, ESLint dà la possibilità di definire dei propri standard del codice, eventualmente derivandoli da altri standard.
Ad esempio, lo standard da noi usato prende spunto dallo stile di \textit{Airbnb}.

È possibile avere un report dell'analisi statica tramite il comando \texttt{yarn lint} nella cartella \texttt{front-end}.
Gli specifici stili estesi e le regole sovrascritte sono invece visibili nel file \texttt{package.json}.

%TODO: Maybe mettere immagine

\subsection{Back-end}

\section{Analisi dinamica}

\subsection{Testing}

Ci siamo occupati di scrivere dei casi di test per poter avere una buona copertura del codice
implementato in questa fase, sia lato front-end sia lato back-end.

\subsubsection{Testing front-end}

Lato front-end, è stato usato il framework \textit{Jest} e la libreria \textit{testing-library} al fine di
esaminare il più possibile la struttura ed il comportamento dell'applicazione web.

Il framework \textit{Jest} riconosce in automatico tutti i file \texttt{Name.test.js} come dei file contenenti
casi di test, li analizza e li esegue tutti in automatico, a qualsiasi livello essi si trovino.

Ad esempio, un estratto del file \texttt{AppRouting.test.jsx} è visibile nel seguente snippet.

\begin{lstlisting}
describe('App routing', () => {
  it('has a home page', () => {
    renderWithRoute('/');
    expect(screen.getByText(/home/i)).toBeInTheDocument();
  });

  it('has an account page', () => {
    renderWithRoute('/account');
    screen.getAllByText(/account/i).forEach((x) => expect(x).toBeInTheDocument());
  });

  it('has a 404 page', () => {
    renderWithRoute('/some/random/route');
    expect(screen.getByText(/404/i)).toBeInTheDocument();
  });
});
\end{lstlisting}

Tramite la libreria di testing usata è possibile anche simulare inserimenti e click dell'utente,
come è visibile in questo estratto di \texttt{Login.test.jsx}.

\begin{lstlisting}
describe('Login page', () => {
  it('has a username input', () => {
    renderWithHistory(<Login />);
    expect(screen.getByPlaceholderText('Inserisci il nome utente')).toBeInTheDocument();
  });

  it('has a password input', () => {
    renderWithHistory(<Login />);
    expect(screen.getByPlaceholderText('Inserisci la password')).toBeInTheDocument();
  });

  it('correctly accepts inputs', () => {
    renderWithHistory(<Login />);
    fireEvent.change(
      screen.getByPlaceholderText('Inserisci il nome utente'),
      { target: { value: 'username' } },
    );
    fireEvent.change(
      screen.getByPlaceholderText('Inserisci la password'),
      { target: { value: 'password123' } },
    );
    fireEvent.click(screen.getByTestId('login-button'));
  });
});
\end{lstlisting}

\subsubsection{Testing back-end}

% TODO: testing backend

\subsection{Coverage}

\subsubsection{Front-end}

Il framework \textit{Jest} permette anche di generare automaticamente la coverage del codice tramite il comando
\texttt{yarn coverage}, esplorabile interattivamente tramite un documento HTML.
In figura \ref{fig:code-coverage-front-end-it1} è visibile la pagina principale di questo documento, che
presenta la copertura di istruzioni, branches, funzioni e righe per ogni cartella del progetto.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{front-end-coverage-it1.jpg}
  \caption{Front-end code coverage}
  \label{fig:code-coverage-front-end-it1}
\end{figure}

In totale, secondo questo primo calcolo, la coverage assume i valori visibili in tabella \ref{tab:code-coverage-front-end-it1}.

\begin{table}
  \centering
  \begin{tabular}{|l|r|}
    \hline Metrica & Copertura percentuale \\
    \hline
    \hline Istruzioni & $91.30\%$ \\
    \hline Branches   & $85.71\%$ \\
    \hline Funzioni   & $97.67\%$ \\
    \hline Righe      & $90.91\%$ \\
    \hline
  \end{tabular}
  \caption{Coverage totale per il front-end}
  \label{tab:code-coverage-front-end-it1}
\end{table}